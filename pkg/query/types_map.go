package query

// Code generated by main v1.0 with go1.11.2 DO NOT EDIT

import (
	"strings"
)

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m FieldMap) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m FieldMap) Values() (values []*Field) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m FieldMap) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m FieldMap) Clone() FieldMap {
	cloned := make(FieldMap)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m FieldMap) Filter(filter func(key string, value *Field) bool) FieldMap {
	filtered := make(FieldMap)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m FieldMap) WithPrefix(prefix string) FieldMap {
	return m.Filter(func(key string, value *Field) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m FieldMap) WithSuffix(suffix string) FieldMap {
	return m.Filter(func(key string, value *Field) bool {
		return strings.HasSuffix(key, suffix)
	})
}

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m FileMap) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m FileMap) Values() (values []*File) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m FileMap) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m FileMap) Clone() FileMap {
	cloned := make(FileMap)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m FileMap) Filter(filter func(key string, value *File) bool) FileMap {
	filtered := make(FileMap)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m FileMap) WithPrefix(prefix string) FileMap {
	return m.Filter(func(key string, value *File) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m FileMap) WithSuffix(suffix string) FileMap {
	return m.Filter(func(key string, value *File) bool {
		return strings.HasSuffix(key, suffix)
	})
}

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m InterfaceMap) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m InterfaceMap) Values() (values []*InterfaceDef) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m InterfaceMap) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m InterfaceMap) Clone() InterfaceMap {
	cloned := make(InterfaceMap)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m InterfaceMap) Filter(filter func(key string, value *InterfaceDef) bool) InterfaceMap {
	filtered := make(InterfaceMap)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m InterfaceMap) WithPrefix(prefix string) InterfaceMap {
	return m.Filter(func(key string, value *InterfaceDef) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m InterfaceMap) WithSuffix(suffix string) InterfaceMap {
	return m.Filter(func(key string, value *InterfaceDef) bool {
		return strings.HasSuffix(key, suffix)
	})
}

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m MethodMap) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m MethodMap) Values() (values []*Method) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m MethodMap) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m MethodMap) Clone() MethodMap {
	cloned := make(MethodMap)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m MethodMap) Filter(filter func(key string, value *Method) bool) MethodMap {
	filtered := make(MethodMap)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m MethodMap) WithPrefix(prefix string) MethodMap {
	return m.Filter(func(key string, value *Method) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m MethodMap) WithSuffix(suffix string) MethodMap {
	return m.Filter(func(key string, value *Method) bool {
		return strings.HasSuffix(key, suffix)
	})
}

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m Packages) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m Packages) Values() (values []*Package) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m Packages) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m Packages) Clone() Packages {
	cloned := make(Packages)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m Packages) Filter(filter func(key string, value *Package) bool) Packages {
	filtered := make(Packages)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m Packages) WithPrefix(prefix string) Packages {
	return m.Filter(func(key string, value *Package) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m Packages) WithSuffix(suffix string) Packages {
	return m.Filter(func(key string, value *Package) bool {
		return strings.HasSuffix(key, suffix)
	})
}

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m StructMap) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m StructMap) Values() (values []*StructDef) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m StructMap) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m StructMap) Clone() StructMap {
	cloned := make(StructMap)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m StructMap) Filter(filter func(key string, value *StructDef) bool) StructMap {
	filtered := make(StructMap)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m StructMap) WithPrefix(prefix string) StructMap {
	return m.Filter(func(key string, value *StructDef) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m StructMap) WithSuffix(suffix string) StructMap {
	return m.Filter(func(key string, value *StructDef) bool {
		return strings.HasSuffix(key, suffix)
	})
}

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m Tags) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m Tags) Values() (values []string) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m Tags) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m Tags) Clone() Tags {
	cloned := make(Tags)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m Tags) Filter(filter func(key string, value string) bool) Tags {
	filtered := make(Tags)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m Tags) WithPrefix(prefix string) Tags {
	return m.Filter(func(key string, value string) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m Tags) WithSuffix(suffix string) Tags {
	return m.Filter(func(key string, value string) bool {
		return strings.HasSuffix(key, suffix)
	})
}

// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m TypeDeclMap) Keys() (keys []string) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m TypeDeclMap) Values() (values []*TypeDecl) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m TypeDeclMap) Contains(key string) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m TypeDeclMap) Clone() TypeDeclMap {
	cloned := make(TypeDeclMap)

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m TypeDeclMap) Filter(filter func(key string, value *TypeDecl) bool) TypeDeclMap {
	filtered := make(TypeDeclMap)

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

// WithPrefix filters the map to only include elements for which contains prefix.
func (m TypeDeclMap) WithPrefix(prefix string) TypeDeclMap {
	return m.Filter(func(key string, value *TypeDecl) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m TypeDeclMap) WithSuffix(suffix string) TypeDeclMap {
	return m.Filter(func(key string, value *TypeDecl) bool {
		return strings.HasSuffix(key, suffix)
	})
}
