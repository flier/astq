package {{ .Package.Name }}

// Code generated by {{ .Generator }} with {{ .GoVersion }} DO NOT EDIT

import (
	"strings"
)

{{ with .File }}
{{   range ( .TypeDecls.WithTag "map" ) }}
{{     if .Type.IsMap }}
// Keys returns a new slice containing the set of map keys. The order is unspecified.
func (m {{ .Name }}) Keys() (keys []{{ .Type.Key }}) {
	for name := range m {
		keys = append(keys, name)
	}

	return
}

// Values returns a new slice containing the set of map values. The order is unspecified.
func (m {{ .Name }}) Values() (values []{{ .Type.Value }}) {
	for _, value := range m {
		values = append(values, value)
	}

	return
}

// Contains reports whether key is within map.
func (m {{ .Name }}) Contains(key {{ .Type.Key }}) bool {
	_, found := m[key]

	return found
}

// Clone returns a shadow copy of map.
func (m {{ .Name }}) Clone() {{ .Name }} {
	cloned := make({{ .Name }})

	for key, value := range m {
		cloned[key] = value
	}

	return cloned
}

// Filter filters the map to only include elements for which filter returns true.
func (m {{ .Name }}) Filter(filter func(key {{ .Type.Key }}, value {{ .Type.Value }}) bool) {{ .Name }} {
	filtered := make({{ .Name }})

	for key, value := range m {
		if filter(key, value) {
			filtered[key] = value
		}
	}

	return filtered
}

{{ if .Type.Key.IsString }}
// WithPrefix filters the map to only include elements for which contains prefix.
func (m {{ .Name }}) WithPrefix(prefix string) {{ .Name }} {
	return m.Filter(func(key {{ .Type.Key }}, value {{ .Type.Value }}) bool {
		return strings.HasPrefix(key, prefix)
	})
}

// WithSuffix filters the map to only include elements for which contains suffix.
func (m {{ .Name }}) WithSuffix(suffix string) {{ .Name }} {
	return m.Filter(func(key {{ .Type.Key }}, value {{ .Type.Value }}) bool {
		return strings.HasSuffix(key, suffix)
	})
}
{{ end }}

{{/* if .Type.Value.IsPtr }}
{{   if (and .Type.Value.Target.HasObject .Type.Value.Target.Object.IsType) }}
func (m {{ .Name }}) WithTag(key string) {{ .Name }} {
	return m.Filter(func(_key {{ .Type.Key }}, _value {{ .Type.Value }}) bool {
		tags := ty.Tags()
		_, found := tags[key]

		return found
	})
}
{{   end }}
{{ end */}}

{{     end }}
{{   end }}
{{ end }}
